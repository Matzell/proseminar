\section{Proof-of-Work}

The idea behind Proof-of type systems is that whoever should be able to add the next block in the blockchain is chosen by proving the ownership of some kind of resource. This resource could be
something determined by computer hardware, like computing power in Proof-of-Work systems or hard drive capacity in Proof-of-Space systems, or it could be determined by some kind of stake ownership
in the system like in Proof-of-Stake systems. Below we will describe some of these systems and compare them to each other.

\subsection{Proof-of-Work}

The first widely used consensus algorithm in blockchains is a so called Proof-of-Work (POW) algorithm. It was and is still being used as the consensus algorithm in the implementation of Bitcoin.\cite{url:bitcoin}
The idea behind a POW algorithm is that the creator of the next block is chosen by him providing a significant amount of computing power. Usually this computing power is provided by solving some
kind of puzzle. 

\subsubsection{Requirements for POW systems}

The puzzle chosen for a POW system can and should have some properties. Firstly it should be computationally hard enough to ensure that a significant amount of computational power should have 
to be expended to be able to solve it otherwise the purpose would be lost. On the other hand however it should also be computationally easy for others in the system to check the correctness 
of a proposed solution. Additionally it should also be possible to adjust the difficulty of the puzzle. This is very important to make the system future proof and to account for the predicted
exponential increase in computing power over the years.\cite{url:moore_law} Additionally in the context of blockchains the difficulty of the puzzle should also account for a potential
increase in computing power within the network caused by the addition of more peers.\par
Lastly there is also the consideration of the usefulness of the puzzle. In most existing implementations
of POW systems the puzzle which should be solved does not provide a higher purpose. In other words the solution of the puzzle has no value other then finding the creator of the next block
and the expended computing power is could be considered to be wasted.\cite{url:pow_useless} There have been some propositions and implementations for "useful" POW type systems. One example is
the algorithm used in the cryptocurrency Primecoin. Primecoin uses a POW type system where a byproduct of the solution for the puzzle is the discovery of potentially new prime numbers.\cite{url:primecoin}

\subsubsection{Examples for existing POW systems}

The first kind of use for a POW type system was called Hashcash and was created to combat spam emails and denial of service attacks. The idea of a system like Hashcash was firstly proposed in 1992
by Cynthia Dwork and Noni Naor.\cite{url:pow_email} The concrete proposal for Hascash and its first implementation followed in 1997.\cite{url:hashcash} The basic idea behind Hashcash is that
the sender takes the header of the email he wants to send, appends a 20 bit long number at the end of it and computes the 160 bit long SHA-1 hash value of it. The goal is to find a hash in which the first 20 bits
are set to zero. If this is not the case the appended number is increased by one and the hash is computed again. This is done until a hash with the first 20 bits set to zero is found. The email
is then sent with the number which satisfies this condition appended to the header. The receiver of the email can then simply try to hash the header himself and he can immediately see if the resulting
hash satisfies the conditions. This system ensures that the sender has to expend some amount of computing power by hashing the header a significant amount of times until it fulfills the condition.
For the receiver however the check can be done immediately since he only has to compute the hash once. Ideally for the sender this means that he has to calculate for some amount of seconds until
he can send out the email which prevents the sending of a lot of potential spam emails at once. This system also accounts for the increase of computing power over the years since the difficulty of
the computation can be increased by increasing the required number of zero bits in the hash.\par
The first use of a POW system for the purpose of a consensus algorithms in a blockchain is however the one used for bitcoins. The idea is very similar to the one used in Hashcash as both systems use a
cryptographic hash function (SHA-256 in Bitcoin) with which they try to find a hash with a certain number of leading zeros, depending on the desired difficulty. Instead of hashing the header of a email
however, in Bitcoin the block which should be added to the chain is hashed. Similar to the Hascash system the block contains a number which is increased until a valid hash is found.
Additionally the new block also contains the hash of the previous block in the chain. This is necessary for once to ensure that the blocks are linked and create a chain but also to make sure that
someone can not try to find a hash for the block after the next one or for a block 10 blocks from the current one. As with Hashcash the difficulty can be adjusted by adjusting the required number
of leading zeros in the hash. In the Bitcoin network this difficulty adjusts itself in such a way that the average time elapsed between two blocks is approximately 10 minutes.\cite{url:bitcoin}\par
Another type of POW algorithm used in cryptocurrencies like Litecoin or Dogecoin is the so called scrypt algorithm.\cite{url:litecoin_dogecoin} The basic concept behind scrypt is that in the first 
step a large number of pseudorandom bit strings are generated. The amount of these bit strings is such that it could very well be possible to run into memory limitations while trying to store 
all the strings. In a second step, these strings are then accessed in pseudorandom order and used to generate a key. Since the execution of this algorithm is not only computationally hard but
also has a significant memory requirement it could also be categorised as a Proof-of-Space type algorithm.\cite{url:scrypt}
